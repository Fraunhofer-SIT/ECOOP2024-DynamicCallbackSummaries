Source: $i0 = virtualinvoke $r1.<java.io.Reader: int read(char[],int,int)>($r2, $i1, $i0)
$i0 = virtualinvoke $r1.<java.io.Reader: int read(char[],int,int)>($r2, $i1, $i0) in <gnu.mapping.TtyInPort: int fill(int)>
Sink: virtualinvoke $r2.<java.io.Writer: void write(char[],int,int)>($r1, $i0, $i1) in <gnu.mapping.LogWriter: void echo(char[],int,int)>

<gnu.mapping.TtyInPort: int fill(int)>: $i0 = virtualinvoke $r1.<java.io.Reader: int read(char[],int,int)>($r2, $i1, $i0)
<gnu.mapping.TtyInPort: int fill(int)>: $r2 = r0.<gnu.mapping.TtyInPort: char[] buffer>
<gnu.mapping.TtyInPort: int fill(int)>: r0 := @this: gnu.mapping.TtyInPort
<gnu.text.LineBufferedReader: int read()>: $i1 = virtualinvoke r0.<gnu.text.LineBufferedReader: int fill(int)>($i1)
<gnu.mapping.TtyInPort: int fill(int)>: $r2 = r0.<gnu.mapping.TtyInPort: char[] buffer>
<gnu.mapping.TtyInPort: int fill(int)>: virtualinvoke $r3.<gnu.mapping.OutPort: void echo(char[],int,int)>($r2, $i1, $i0)
<gnu.mapping.OutPort: void echo(char[],int,int)>: virtualinvoke $r3.<gnu.mapping.LogWriter: void echo(char[],int,int)>($r1, $i0, $i1)
<gnu.mapping.LogWriter: void echo(char[],int,int)>: virtualinvoke $r2.<java.io.Writer: void write(char[],int,int)>($r1, $i0, $i1)
